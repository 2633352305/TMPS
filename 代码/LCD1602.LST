C51 COMPILER V9.59.0.0   LCD1602                                                           04/24/2025 21:34:02 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE LCD1602
OBJECT MODULE PLACED IN ..\LCD1602.obj
COMPILER INVOKED BY: C:\Keil_C51\C51\BIN\C51.EXE LCD1602.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2) OBJECT(..
                    -\LCD1602.obj)

line level    source

   1          /*************************************************************
   2                                LCD1602源文件
   3          
   4          实现功能：LCD1602的控制
   5          
   6          ***************************************************************/
   7          #include <LCD1602.h> // 包含头文件以获取声明和引脚定义
   8          #include <reg52.h>   // 包含寄存器定义
   9          #include <intrins.h> // 包含 _nop_
  10          
  11          /*****************LCD1602自定义字符"℃↑↓"*******************/
  12          // 定义 CGRAM_TABLE 数组
  13          unsigned char code CGRAM_TABLE[] = {
  14              // ℃↑↓符号字模数据
  15              0x00,0x0E,0x0A,0x0E,0x00,0x00,0x00,0x00, // ℃ (Index 0)
  16              0x04,0x0A,0x15,0x04,0x04,0x04,0x04,0x00, // ↑ (Index 1)
  17              0x00,0x04,0x04,0x04,0x04,0x15,0x0A,0x04  // ↓ (Index 2)
  18          };
  19          
  20          /********************************************************
  21          函数名称:void delay_n40us(uint n)
  22          函数作用:LCD1602延时函数 (粗略延时)
  23          参数说明:n - 延时参数 (每个循环约40us @ 11.0592MHz)
  24          ********************************************************/
  25          void delay_n40us(uint n)
  26          {
  27   1          while(n--)
  28   1          {
  29   2              // 16个 _nop_ 大约是 16 * 12 / 11.0592 = 17.3 us
  30   2              // 这里使用32个nop，大约35us，加上循环开销接近40us
  31   2              _nop_(); _nop_(); _nop_(); _nop_();
  32   2              _nop_(); _nop_(); _nop_(); _nop_();
  33   2              _nop_(); _nop_(); _nop_(); _nop_();
  34   2              _nop_(); _nop_(); _nop_(); _nop_();
  35   2              _nop_(); _nop_(); _nop_(); _nop_();
  36   2              _nop_(); _nop_(); _nop_(); _nop_();
  37   2              _nop_(); _nop_(); _nop_(); _nop_();
  38   2              _nop_(); _nop_(); _nop_(); _nop_();
  39   2          }
  40   1      }
  41          
  42          /********************************************************
  43          函数名称:void Timer0_Delay(uint ms)
  44          函数作用:使用定时器0实现精确延时
  45          参数说明:ms - 延时毫秒数
  46          ********************************************************/
  47          void Timer0_Delay(uint ms)
  48          {
  49   1          TMOD &= 0xF0; // 清除T0配置位
  50   1          TMOD |= 0x01; // 设置定时器0为模式1 (16位定时器)
  51   1          TR0 = 0;      // 停止定时器0
  52   1          ET0 = 0;      // 禁止定时器0中断
  53   1          for(; ms > 0; ms--)
  54   1          {
C51 COMPILER V9.59.0.0   LCD1602                                                           04/24/2025 21:34:02 PAGE 2   

  55   2              TH0 = 0xFC; // 1ms定时初值 (@11.0592MHz: 65536 - 11059200 / 12 / 1000 = 64614 -> FC66H)
  56   2              TL0 = 0x66; // 使用 FC66H 以获得更精确的1ms
  57   2              TF0 = 0;    // 清除溢出标志
  58   2              TR0 = 1;    // 启动定时器0
  59   2              while(!TF0); // 等待定时器0溢出
  60   2              TR0 = 0;    // 停止定时器0
  61   2          }
  62   1      }
  63          
  64          /********************************************************
  65          函数名称:void LCD_write_command(uchar command)
  66          函数作用:LCD1602写命令
  67          参数说明:command为指令，参考数据手册
  68          ********************************************************/
  69          void LCD_write_command(uchar command)
  70          {
  71   1          LCD_RS = 0; // 选择指令寄存器
  72   1          LCD_RW = 0; // 选择写模式
  73   1          LCD_DB = command; // 发送指令
  74   1          delay_n40us(1); // Ts1: 地址建立时间 > 40ns (这里给1个循环约40us，足够)
  75   1          LCD_E = 1;  // 拉高使能信号
  76   1          // Tpw: E脉冲宽度 > 230ns (delay_n40us(1) ~40us >> 230ns)
  77   1          delay_n40us(1);
  78   1          LCD_E = 0;  // 拉低使能信号
  79   1          delay_n40us(1); // Th1: 地址保持时间 > 10ns (这里给~40us)
  80   1          // 指令执行时间不同，最长1.64ms (清屏)，其他大部分<40us
  81   1          // 在调用处根据需要加延时，尤其是清屏和归位指令后
  82   1      }
  83          
  84          /********************************************************
  85          函数名称:void LCD_write_data(uchar dat)
  86          函数作用:LCD1602写数据
  87          参数说明:dat - 要写入的数据
  88          ********************************************************/
  89          void LCD_write_data(uchar dat)
  90          {
  91   1          LCD_RS = 1; // 选择数据寄存器
  92   1          LCD_RW = 0; // 选择写模式
  93   1          LCD_DB = dat; // 发送数据
  94   1          delay_n40us(1); // Ts1 > 40ns
  95   1          LCD_E = 1;  // 拉高使能信号
  96   1          // Tpw > 230ns
  97   1          delay_n40us(1);
  98   1          LCD_E = 0;  // 拉低使能信号
  99   1          delay_n40us(1); // Th1 > 10ns
 100   1      }
 101          
 102          /********************************************************
 103          函数名称:void LCD_init(void)
 104          函数作用:LCD1602初始化函数
 105          参数说明:无
 106          ********************************************************/
 107          void LCD_init(void)
 108          {
 109   1          Timer0_Delay(15); // 上电延时 > 15ms
 110   1          LCD_write_command(0x38); // 功能设置：8位数据，2行显示，5x7点阵 (无需延时)
 111   1          Timer0_Delay(5);  // 延时 > 4.1ms
 112   1          LCD_write_command(0x38); // 第二次功能设置
 113   1          Timer0_Delay(1);  // 延时 > 100us
 114   1          LCD_write_command(0x38); // 第三次功能设置
 115   1          Timer0_Delay(1);
 116   1      
C51 COMPILER V9.59.0.0   LCD1602                                                           04/24/2025 21:34:02 PAGE 3   

 117   1          // 从这里开始可以查询忙标志，但为了简化，使用固定延时
 118   1          LCD_write_command(0x38); // 确认功能设置: 8位，2行，5x7
 119   1          Timer0_Delay(1);
 120   1          LCD_write_command(0x08); // 显示关闭
 121   1          Timer0_Delay(1);
 122   1          LCD_clear(); // 调用清屏函数
 123   1          LCD_write_command(0x06); // 进入点设置：光标右移，屏幕不移动
 124   1          Timer0_Delay(1);
 125   1          LCD_write_command(0x0C); // 显示开，关光标，不闪烁
 126   1          Timer0_Delay(1);
 127   1      }
 128          
 129          /********************************************************
 130          函数名称:void LCD_clear(void)
 131          函数作用:清除LCD屏幕
 132          参数说明:无
 133          ********************************************************/
 134          void LCD_clear(void)
 135          {
 136   1          LCD_write_command(0x01); // 发送清屏指令
 137   1          Timer0_Delay(2);         // 清屏指令需要较长延时 > 1.64ms
 138   1      }
 139          
 140          /********************************************************
 141          函数名称:void LCD_disp_char(uchar x, uchar y, uchar dat)
 142          函数作用:LCD1602在指定位置显示一个字符
 143          参数说明:x - 列坐标 (0-15), y - 行坐标 (1-2), dat - 要显示的字符
 144          ********************************************************/
 145          void LCD_disp_char(uchar x, uchar y, uchar dat)
 146          {
 147   1          uchar address;
 148   1          if (y == 1)
 149   1          {
 150   2              address = 0x80 + x; // 第一行地址
 151   2          }
 152   1          else if (y == 2)
 153   1          {
 154   2              address = 0xC0 + x; // 第二行地址
 155   2          }
 156   1          else
 157   1          {
 158   2              return; // 无效行号
 159   2          }
 160   1          LCD_write_command(address); // 设置 DDRAM 地址
 161   1          LCD_write_data(dat);        // 写入字符数据
 162   1      }
 163          
 164          /********************************************************
 165          函数名称:void lcd1602_write_character(uchar x, uchar y, uchar *s)
 166          函数作用:LCD1602在指定位置开始显示一个字符串
 167          参数说明:x - 列坐标 (0-15), y - 行坐标 (1-2), *s - 要显示的字符串指针
 168          ********************************************************/
 169          void lcd1602_write_character(uchar x, uchar y, uchar *s)
 170          {
 171   1          uchar address;
 172   1          if (y == 1)
 173   1          {
 174   2              address = 0x80 + x; // 第一行地址
 175   2          }
 176   1          else if (y == 2)
 177   1          {
 178   2              address = 0xC0 + x; // 第二行地址
C51 COMPILER V9.59.0.0   LCD1602                                                           04/24/2025 21:34:02 PAGE 4   

 179   2          }
 180   1          else
 181   1          {
 182   2              return; // 无效行号
 183   2          }
 184   1          LCD_write_command(address); // 设置起始 DDRAM 地址
 185   1          while (*s != '\0')          // 使用正确的 null terminator '
 186   1          {
 187   2              LCD_write_data(*s++);
 188   2          }
 189   1      }
 190          
 191          /********************************************************
 192          函数名称:void lcd1602_write_pic(uchar add, uchar *pic_num)
 193          函数作用:LCD1602写入自定义字符数据到CGRAM
 194          参数说明:add - 自定义字符索引 (0-7), *pic_num - 8字节字模数据指针
 195          ********************************************************/
 196          void lcd1602_write_pic(uchar add, uchar *pic_num)
 197          {
 198   1          unsigned char i;
 199   1          if (add > 7) return; // 最多8个自定义字符
 200   1          LCD_write_command(CGRAM_ADDR(add)); // 设置 CGRAM 地址
 201   1          for(i = 0; i < 8; i++)              // 写入8字节的字模数据
 202   1          {
 203   2              LCD_write_data(pic_num[i]);     // 注意：这里假设pic_num指向RAM，如果指向code，需
             -调整
 204   2              // 如果 pic_num 指向 code 存储器，应该使用指针访问: LCD_write_data(*(pic_num+i));
 205   2              // 但由于 CGRAM_TABLE 是 code 类型，调用时如 lcd1602_write_pic(0, &CGRAM_TABLE[0])
 206   2              // 传递的是 code 指针，直接用 pic_num[i] 或 *(pic_num+i) 都可以，编译器能处理
             -。
 207   2          }
 208   1          LCD_write_command(0x80); // 操作完CGRAM后，将地址指针重新设置到DDRAM，避免后续显
             -混乱
 209   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    386    ----
   CONSTANT SIZE    =     24    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
